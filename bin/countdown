#!/usr/bin/env python3
'''
Countdown date utility.

Mostly for my own use, but feel free to hack around with it!

Works well with `pip install rich` for rich text formatting, but it's not necessary.

Takes some countdown text file. I use
`alias countdown='countdown my_path [my_opts]'` for config.

The countdown file itself has lines of the format:

YYYY Mon DD Eventname
2023 Jun 03 Example Countdown

Comments of the form:
# Category [richstyle]
# Movies example [bold red]
# Unformatted example

give categories (and style) to events below them, useful for collation.
'''

from dataclasses import dataclass
from os import system
import re
from typing import Generator

from argparse import ArgumentParser
from datetime import date as Date, datetime as Datetime, timedelta as Timedelta
from pathlib import Path
from sys import exit

try:
    from rich.console import Console
except:
    Console = None


@dataclass(frozen=True)
class Category:
    name: str = ''
    style: str = ''

    @classmethod
    def from_string(cls, string: str):
        name = string
        style = ''
        if '[' in string:
            name, style = string.split('[', 1)
            style = style.removesuffix(']')

        return cls(name.strip(), style.strip())

    def __str__(self):
        return '    ' + self.name

    def __rich__(self):
        return f'    [bold {self.style}]{self.name}'


@dataclass(frozen=True)
class Event:
    date: Date
    name: str
    category: Category

    def days_until(self):
        today = Date.today()
        return (e.date - today).days

    def __str__(self):
        return f'{self.days_until():>3} {self.name}'

    def __rich__(self):
        return f'[bold cyan]{self.days_until():>3}[/] [italic {self.category.style}]{self.name}[/]'


EVENT = re.compile(r"(?:(\d{2,4}) )?([A-Za-z]{3}) (\d\d) (.+)")

def get_events(filename: Path) -> Generator[Event, None, None]:
    today = Datetime.today()

    with open(filename) as f:
        category = Category()
        for i, line in enumerate(f, start=1):
            line = line.strip()
            if not line:
                continue

            if line.startswith('#'):
                if '[' in line:
                    category = Category.from_string(line.removeprefix('#'))
                continue

            match = EVENT.match(line)
            if not match:
                parser.exit(2, f"Error! {filename}:{i} is not a well-formed date:\n{line}\n")

            y, m, d, name = match.groups()
            y = y or today.year  # TODO: shunt to next year? use -p maybe?
            dt = Datetime.strptime(f'{y} {m} {d}', '%Y %b %d')

            yield Event(dt.date(), name, category)


parser = ArgumentParser()
parser.add_argument(
    'file',
    help="The countdown file.")

_event_filter = parser.add_argument_group("event filter")

_event_filter.add_argument(
    '-a', '--all', action='store_true',
    help="Show all events.")
_event_filter.add_argument(
    '-n', '--number', default=5, type=int,
    help="Number of events to display.")
_event_filter.add_argument(
    '-p', '--past', nargs='?', default=0, const=None, type=int, metavar='DAYS',
    help="Number of days in the past to display. Provide no number to show all past events.")

_display = parser.add_argument_group("display mode")
_event_filter.add_argument(
    '--no-rich', action='store_true',
    help="Do not display color or styling.")
_display.add_argument(
    '-c', '--categories', action='store_true',
    help="Show countdowns by category.")
_display.add_argument(
    '-d', '--days-until', metavar='NAME',
    help="Return only the countdown number to a specific event. Exits with code 9 if event not found.")

editing = parser.add_argument_group("file")

editing.add_argument(
    '-e', '--edit', action='store_true',
    help="Open the file in $EDITOR.")


if __name__ == '__main__':
    # post-process args
    args = parser.parse_args()
    if args.all:
        args.number = None
        args.past = None
    
    if args.no_rich:
        Console = None
    
    if args.edit:
        system(f'$EDITOR "{args.file}"')
    
    # display

    _print = print
    def print(*objects):
        if Console is None:
            _print(*objects)
        else:
            Console().print(*objects, highlight=False)
    
    # get events

    today = Date.today()
    events = get_events(args.file)
    
    # handle specific countdown

    if args.days_until is not None:
        for e in events:
            if e.name == args.days_until:
                print(e.days_until())
                exit(0)
        else:
            exit(9)
    
    # filter

    if args.past is not None:
        minim = -args.past - 1
        events = filter(lambda x: (x.date - today).days > minim, events)

    events = sorted(events, key=lambda x: x.date)[:args.number]
    
    # display

    if args.categories:
        cats: dict[Category, list[Event]] = dict()
        for e in events:
            cats.setdefault(e.category, [])
            cats[e.category].append(e)

        for c, es in cats.items():
            print(c)
            for e in es:
                print(e)
    else:
        for e in events:
            print(e)
